class @FR2.CommentForm
  SUBMIT_BUTTON_REFRESH_INTERVAL = 2000

  constructor: (commentFormId, commentFormHandler)->
    @commentFormId = commentFormId
    @commentFormHandler = commentFormHandler

    @notSentFieldIds = [
      '#comment_confirmation_text',
      '#comment_confirm_submission_input'
    ]

    @uploadsInProgress = false

  initialize: ->
    @addFormEvents()
    @addCommentSecret()
    @setSubmitButtonState()
    @addSubmitButtonWarningModal()
    @_updateCommentCategories()
    @_addSubmitterTypeHandling()
    @_setSubmitterType()
    @_addInlineValidations()

  commentFormEl: ->
    if @_commentFormEl == null || @_commentFormEl == undefined || @_commentFormEl == []
      $( @commentFormId )
    else
      @_commentFormEl

  commentFormFileUploader: ->
    @commentFormHandler.commentFormFileUploader

  commentFormStore: ->
    @commentFormHandler.commentFormStore

  addFormEvents: ->
    @comboBoxChangeHandler()
    @_respondToRequiredFieldChanges()
    @removeErrorsOnChange()
    @maxCharacterWarning()
    @confirmCommentSubmission()
    @formSubmit()
    @_refreshSubmitButtonStateOnInterval()

  parseFields: ->
    fields = []
    $els = @commentFormEl().find('.inputs > ol > li')

    $els = @removeNotSentFields($els)

    _.each $els, (el)=>
      listItem = $(el)
      key = listItem.find('label').text().replace('*','')
      field = {'label': key}

      if listItem.hasClass('combo')
        input = listItem.find('select').first()
        if input.length > 0
          field.values = Array @getOptionValue(input)
        else
          field.values = Array @getItemValue(listItem, 'input')

      else if listItem.hasClass('stringish')
        field.values = Array @getItemValue(listItem, 'input')
      else if listItem.hasClass('text')
        field.values = Array @getItemValue(listItem, 'textarea')
      else if listItem.hasClass('select')
        input = listItem.find('select').first()
        field.values = Array @getOptionValue(input)
      else if listItem.hasClass('file')
        attachments = listItem.find('.attachments tr')

        attachment_names = _.map attachments, (el)->
          $(el).data('name')

        if attachment_names.length
          field.values =  attachment_names
        else
          Array 'None attached'

      fields.push field

    fields

  removeNotSentFields: ($els)->
    _.each @notSentFieldIds, (id)->
      $els = $els.filter("li:not(#{id})")

    $els

  getOptionValue: ($input)->
    $input.find('option[value="' + $input.val() + '"]').first().text()

  getItemValue: ($item, type)->
    $item.find(type).val()

  comboBoxChangeHandler: ->
    _.each @commentFormEl().find('li.combo'), (li)=>
      $li = $(li)
      dependencies = $li.data('dependencies')
      input = $li.find('input')

      @commentFormEl().find("select[name='comment[#{$li.data('dependent-on')}]']")
        .change ->
          parentSelect = $(this)
          parentValue = parentSelect.val()

          $li.find('select').remove()

          if dependencies[parentValue]
            currentValue = input.val()
            select = $("<select name='#{input.attr('name')}'><option></option></select>")

            _.map dependencies[parentValue], (options)->
              option = $('<option>')
              option
                .attr 'value', options[0]
                .text options[1]
              select.append option

            select.val currentValue

            input
              .prop 'disabled', true
              .hide()
              .val ''
              .after select
          else
            input
              .prop 'disabled', false
              .show()

        .change()

  addCommentSecret: ->
    commentSecret = @commentFormEl().find '#comment_secret'

    if commentSecret.val() == ''
      commentSecret.val Math.random().toString(36).substring(2,16)

  removeErrorsOnChange: ->
    @commentFormEl().on 'change', 'select', (e)->
      select = $(this)

      select
        .siblings '.inline-errors'
        .remove()
      select
        .closest 'li'
        .removeClass 'error'

    @commentFormEl().on 'change keyup', 'li.error.input', (e)->
      FR2.FormUtils.validateField this

  maxCharacterWarning: ->
    @commentFormEl().on 'change keyup', 'li.input[data-max-size]', ()->
      FR2.FormUtils.enforceCharactersRemaining this

  submitButtonWrapper: ->
    @commentFormEl().find '.button.commit'

  commentConfirmationCheckbox: ->
    @commentFormEl().find '#comment_confirm_submission'

  confirmCommentSubmission: ->
    @commentFormEl().on 'change', @commentConfirmationCheckbox(), ()=>
      @setSubmitButtonState()

  setSubmitButtonState: ()->
    #TODO: If needed, wire in the equivalent V4 uploader is ready logic.
    if @commentConfirmationChecked() && @_formPassesPrevalidation()#@uploaderReady()
      @enableSubmitButton()
    else
      @disableSubmitButton()

  commentConfirmationChecked: ->
    @commentConfirmationCheckbox().is ':checked'

  formSubmit: ->
    @commentFormEl().on 'click', '.button.commit:not(.submitting, .disabled)', (e)=>
      e.preventDefault()

      @commentFormHandler.submitCommentForm()

  storeComment: ->
    @commentFormHandler.storeComment()

  loadComment: (commentData) ->
    _.map commentData, (value, name) =>
      @commentFormEl().find("[name='" + name + "']").val(value)

  enableSubmitButton: ->
    @submitButtonWrapper()
      .removeClass 'disabled'
      .find 'input'
      .prop 'disabled', false

    @submitButtonWrapper()
      .find '.event-overlay'
      .remove()

  disableSubmitButton: ->
    @submitButtonWrapper()
      .addClass 'disabled'
      .find 'input'
      .prop 'disabled', true

    # FF doesn't propagate events on disabled elements,
    # it complete ignores them. The overlay gets around that
    # by sitting over the input to gather the click and then
    # essentially passing that click on to the proper element
    overlay = @submitButtonWrapper()
      .find '.event-overlay'

    if overlay.length == 0
      overlay = $('<div>').addClass 'event-overlay'

      overlay
        .css({
          position: "absolute"
          top: 0
          left: 0
          width: @submitButtonWrapper().outerWidth()
          height: @submitButtonWrapper().outerHeight()
          zIndex: 2000
          # IE needs a color in order for the layer to respond to mouse events
          backgroundColor: "#FFF"
          opacity: 0
        })
        .on 'click', (e)=>
          e.preventDefault()
          e.stopPropagation()
          @submitButtonWrapper()
            .trigger 'click'

      @submitButtonWrapper()
        .append overlay

  # acts as getter/setter
  uploaderReady: (status)->
    if status?
      @uploaderReadyStatus = status
      @setSubmitButtonState()

    @uploaderReadyStatus

  getSubmitButtonState: ->
    if ! @uploaderReady()
      if @commentFormFileUploader().uploaderHasErrors()
        "Some of your files have errors. Please remove the files and try again."
      else if @commentFormFileUploader().uploaderInProgress()
        "Your files are still being uploaded. Please wait until they are complete and try again."
    else if ! @commentConfirmationChecked()
      "Please read and confirm the statement regarding the submission of personal information."
    else if ! @_formPassesPrevalidation()
      "Please ensure all required fields in the form above are populated."
    else
      false

  addSubmitButtonWarningModal: ->
    @submitButtonWrapper().on 'click', (e)=>
      if @submitButtonWrapper().hasClass 'disabled'
        e.preventDefault()
        e.stopPropagation()

        modalTitle = 'Unable to Submit Comment'
        modalHtml  = @getSubmitButtonState()

        FR2.Modal.displayModal modalTitle, modalHtml

  reset: ->
    @commentFormEl().trigger("reset")
    @commentFormFileUploader().reset()
    @_clearSubmitterType()
    @setSubmitButtonState()

  _clearSubmitterType: ->
    # Remove 'selected' color from all submitter icons
    $('.submitter-type-js .icon-fr2').removeClass('selected')

    # Set submitter type field
    $("#comment_submitterType").val(null)

    # Toggle field visibility
    $('.submitter-section-js').addClass('cj-hidden')

  _updateCommentCategories: ->
    context = this
    $.ajax(
      url: "#{context.commentFormHandler.regulationsDotGovBaseUrl()}/agency-categories?filter[acronym]=#{context._agencyAcronym()}",
      type: "GET",
      contentType: "application/vnd.api+json",
      crossDomain: true,
      dataType: 'json',
      excludeCsrfTokenHeader: true,
      beforeSend: (xhr, settings) ->
        xhr.setRequestHeader(
          'x-api-key',
          context.commentFormHandler.apiKey()
        )
      success: (data, status) =>
        categoryDropdown = $("#comment_category")
        if data.data.length > 0
          $.each(data.data, (x) ->
            category = this.attributes.category
            categoryDropdown.append($("<option />").val(category).text(category))
          )
        else
          $('#comment_category_input').addClass('cj-hidden')
      error: () ->
        modalTitle = "Regulations.gov Unavailable"
        modalHtml = "
          <p>
            Regulations.gov appears to be unavailable.  You may view the comment form below, but you'll need to submit your commment a bit later.
          </p>"
        FR2.Modal.displayModal modalTitle, modalHtml
    )

  _agencyAcronym: ->
    $('#comment-bar').data('reggov-agency')

  _addSubmitterTypeHandling: ->
    context = this
    $("#new_comment").on( "click", ".submitter-type-js", () ->
      dataSubmitterTypeIdentifier = $(this).data('submitter-type')

      # Remove 'selected' color from all submitter icons
      $('.submitter-type-js .icon-fr2').each (index) -> $(this).removeClass('selected')
      # Add 'selected' color to selected submitter icon
      $(this).find('.icon-fr2').addClass('selected')

      # Deselect all radio options
      $('.submitter-type-js input:radio').prop('checked', false)

      # Select radio option for submitter type
      $(this).find('input:radio').prop('checked', true)

      # Set submitter type field
      $("#comment_submitterType").val( dataSubmitterTypeIdentifier.toUpperCase() )

      # Toggle field visibility
      $('.submitter-section-js').each( (index) ->
        if $(this).data('submitter-type') == dataSubmitterTypeIdentifier
          $(this).removeClass('cj-hidden')
        else
          $(this).addClass('cj-hidden')
      )

      # Ensure inline validations are recalculated based on fields made visible/hidden via submitter type selection
      context.setSubmitButtonState()
    )

  _formPassesPrevalidation: () ->
    _.all(this._requiredFields(), (el) ->
      $(el).val() != ""
    )

  _requiredFields: () ->
    isVisible = (el) ->
      $(el).is(":visible")
    _.filter(this._validatableFields(), isVisible).
      concat( $("#comment_submitterType") ) #Add submitter type since it's a hidden field

  _validatableFields: () ->
    $('#new_comment .validate-required-js textarea, #new_comment .validate-required-js input, #new_comment .validate-required-js select')

  _addInlineValidations: () ->
    this._validatableFields().each () ->
      $(this).on('blur', () ->
        if $(this).val() == ''
          $(this).closest('li').find('.inline-errors').remove()
          $(this).after("<p class='inline-errors'>This field is required</p>")
        else
          # TODO: Ensure this takes into account the length validation on the text field
          $(this).closest('li').find('.inline-errors').remove()
      )

  _respondToRequiredFieldChanges: () ->
    context = this
    $(".validate-required-js").change( (e) ->
      context.setSubmitButtonState()
    )

  _setSubmitterType: () ->
    # Must be called after _addSubmitterTypeHandling
    # We could extract the binding events to a _toggleSubmitterType function in the future and call from both initializer functions
    if @commentFormStore().hasStoredComment()
      submitterType = @commentFormStore().getStoredComment()['comment[submitterType]']
      if submitterType
        $("#comment_submitterType").val(submitterType)

        $('.submitter-type-js[data-submitter-type="' + submitterType.toLowerCase() + '"]')
          .first()
          .click()

  _refreshSubmitButtonStateOnInterval: () ->
    context = this
    this.refreshIntervalId = setInterval(
      context.setSubmitButtonState.bind(context),
      context.SUBMIT_BUTTON_REFRESH_INTERVAL
    )
