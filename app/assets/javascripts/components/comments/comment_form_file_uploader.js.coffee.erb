#=require app

class @FR2.CommentFormFileUploader
  @ATTACHED_COMMENT_MESSAGE: 'See attached file(s)'

  constructor: (commentFormHandler)->
    @fileUploadSubmissionKey = null
    @commentFormHandler = commentFormHandler
    @submissionKeyUrl = "<%= Settings.regulations_dot_gov.api_base_url %>/submission-keys"
    @fileUploadUrlsUrl = "<%= Settings.regulations_dot_gov.api_base_url %>/file-upload-urls"
    @uploadedFiles = []

  initialize: ->
    @attachUploader()
    @addCompleteEvents()
    @addUploadEvents()
    @addDestroyEvents()
    @displayExistingAttachments()
    @displayAttachmentErrors()
    @commentForm().uploaderReady true

  commentForm: ->
    @commentFormHandler.commentForm

  commentFormEl: ->
    @commentForm().commentFormEl()

  commentField: ->
    @commentFormEl()
      .find '#comment_general_comment'

  attachmentContainer: ->
    @commentFormEl()
      .find '.attachments tbody'

  existingAttachments: ->
    @commentFormEl()
      .find '.attachments'
      .data 'existing'

  attachedCommentMessage: ->
    @constructor.ATTACHED_COMMENT_MESSAGE

  attachUploader: ->
    @uploaderEl = $( @commentFormEl().find('#fileupload') )
    uploader = @

    @uploader = @uploaderEl.fileupload(
      {
        url: ''
        dataType: 'json',
        autoUpload: true,
        sequentialUploads: true
        add: (e, data) =>
          @uploadFileToRegulationsDotGovBucket(data)
          true
        formData: {},
        filesContainer: @attachmentContainer()
        uploadTemplateId: null
        downloadTemplateId: null
        uploadTemplate: (o)->
          source = $("#comment-attachment-upload-template").html()
          template = Handlebars.compile source
          template o
        downloadTemplate: (o)->
          source = $("#comment-attachment-complete-template").html()
          template = Handlebars.compile source
          template o
      }
    )
    .data('blueimpFileupload')

  uploadFileToRegulationsDotGovBucket: (data) ->
    data = data
    uploader = @

    # Ensure populated submission key before uploading document
    @fetchFileUploadSubmissionKey()
      .done (submissionKey) =>
        console.log("Key retrieved: " + submissionKey)
        # data.url = "https://fr-test-bucket-01.s3-us-west-2.amazonaws.com/capybara3.jpg"

        # Fetch a file upload URL for each file selected
        $.each data.files, (i, file) =>
          console.log("Processing file: " + file.name)
          @populateFileUploadUrlOnFile(file)
            .done (fileUploadUrl) ->

              # TODO: Investigate saving the fileUploadUrl on the file object
              # instead of creating a new mapping object
              # then retrieve the URLs when persisting comment receipt
              file.fileUploadUrl = fileUploadUrl
              uploader.uploadedFiles.push(file)

              data.process().done (data) =>
                data.type = "PUT"
                data.url = fileUploadUrl
                data.data = data.files[0] # TODO: support multiple files
                data.crossDomain = true
                data.fileUploadUrl = fileUploadUrl
                data.contentType = false
                data.processData = false
                # TODO: may have to break out into multiple $.ajax calls for multipl submissions
                data.submit()
      .fail () =>
        # TODO: handle failures
        console.log('Failed to fetch file upload submission key')

  fetchFileUploadSubmissionKey: ->
    deferred = $.Deferred()

    unless @fileUploadSubmissionKey
      $.ajax(
        url: @submissionKeyUrl,
        type: "POST",
        contentType: "application/vnd.api+json",
        crossDomain: true,
        data: JSON.stringify({ data: { type: "submission-keys" }}),
        dataType: 'json',
        beforeSend: (xhr, settings) ->
          xhr.setRequestHeader(
            'x-api-key',
            "<%= Settings.regulations_dot_gov.api_key %>"
          )
        success: (res, status) =>
          @fileUploadSubmissionKey = res.data.id
          deferred.resolve(@fileUploadSubmissionKey)
        error: () ->
          @fileUploadSubmissionKey = "key"
          deferred.reject()
        complete: ->
      )
    else
      deferred.resolve(@fileUploadSubmissionKey)

    return deferred.promise()

  populateFileUploadUrlOnFile: (file) ->
    deferred = $.Deferred()

    $.ajax(
      url: @fileUploadUrlsUrl,
      type: "POST",
      contentType: "application/vnd.api+json",
      crossDomain: true,
      data: JSON.stringify({
        data: {
          type: "file-upload-urls",
          attributes: {
            fileName: file.name,
            submissionKey: @fileUploadSubmissionKey,
            # TODO: support other content types
            contentType: "image/jpeg"
          }
        }
      }),
      dataType: 'json',
      beforeSend: (xhr, settings) ->
        xhr.setRequestHeader(
          'x-api-key',
          "<%= Rails.application.secrets[:data_dot_gov][:v4_commenting_api_key] %>"
        )
      success: (res, status) =>
        deferred.resolve(res.data.id)
      error: () ->
        deferred.reject()
      complete: ->
    )

    return deferred.promise()

  attachmentEl: ->
    $('.attachments tbody')

  filesUploading: ->
    @attachmentEl()
      .find '.template-upload'
      .not '.error'
      .length > 0

  filesWithErrors: ->
    @attachmentEl()
      .find '.template-upload.error'
      .length > 0

  uploaderInProgress: ->
    @filesUploading()

  uploaderHasErrors: ->
    @filesWithErrors()

  uploaderReady: ->
    ! @uploaderInProgress() && ! @uploaderHasErrors()

  updateUploaderStatus: (event)->
    if event == 'submit' || event == 'fail'
      @commentForm().uploaderReady false
    else if (event == 'complete' || event == 'destroy') && @uploaderReady()
      @commentForm().uploaderReady true

  addUploadEvents: ->
    @uploaderEl
      .bind 'fileuploadsubmit', (e, data)=>
        @updateUploaderStatus 'submit'
        true

    @uploaderEl
      .bind 'fileuploadprocessfail', (e, data)=>
        @updateUploaderStatus 'fail'
        if data.files.error
          _.each data.context, (el, index)=>
            error = data.files[index].error
            $el = $(el)
            if error
              $el
                .closest 'tr'
                .addClass 'error'
              $el
                .find '.progress-bar'
                .html error
              $el
                .find '.button.cancel .action'
                .text 'Delete'

    # this is triggered when a file with an error is removed
    # from the file list - go figure...
    @uploaderEl
      .bind 'fileuploadfail', (e,data)=>
        @updateUploaderStatus 'destroy'

  addCompleteEvents: ->
    @uploaderEl.bind 'fileuploadcompleted', (e, data)=>
      if @commentField().val() == ''
        @commentField().val( @attachedCommentMessage() )

      @commentForm().storeComment()
      @updateUploaderStatus 'complete'

  addDestroyEvents: ->
    @uploaderEl.bind 'fileuploaddestroyed', =>
      @clearCommentPlaceholder()
      @updateUploaderStatus 'destroy'

  clearCommentPlaceholder: ->
    if @commentField().val() == @attachedCommentMessage() && @attachmentContainer().children('tr:not(.error)').length == 0
      @commentField().val ''

  displayExistingAttachments: ->
    @uploader
      ._renderDownload @existingAttachments()
      .appendTo @attachmentContainer()

    @clearCommentPlaceholder()

  displayAttachmentErrors: ->
    priorValidations = @uploader._hasError
    fileUploader = this

    @uploader._hasError = (file)->
      _.each fileUploader.attachmentContainer().find('tr'), (i, el)->
        $el = $(el)
        if $el.data('name') == file.name
          file.error = 'A file with the same name has already been attached.'

      priorValidations.call(this, file)
